package render

import sg "../../libs/sokol/gfx"
import tt "../../libs/stb/truetype"

import game "../../types/game"
import io "../platform"

import "core:fmt"
import "core:log"
import "core:strings"

// size constraints for each fonts bitmap
BITMAP_WIDTH :: 512
BITMAP_HEIGHT :: 512

Font :: struct {
	texture:  sg.Image,
	view:     sg.View, // we need to store a view for drawing
	charData: [96]tt.bakedchar,
	name:     string, // id for a font
}

@(private)
_fontCache: map[string]Font

getFont :: proc(id: game.FontName, size: int) -> (Font, bool) {
	if id == .nil {
		log.error("Got .nil font id.")
		return {}, false
	}

	name := fmt.tprintf("%v", id)
	key := fmt.tprintf("%s_%d", name, size)

	if key in _fontCache {
		setFontTexture(_fontCache[key].view) //TODO: move this out of here, preferably without forcing it in draw loop.
		//maybe move it to drawText?
		return _fontCache[key], true
	}

	// we use the autogenerated data via the CLI.
	// fontFilename is a map to directories in which font files live
	filename := game.fontFilename[id]
	path := fmt.tprintf("assets/fonts/%s", filename)

	// io.read_entire_file is a platform-agnostic implementation of
	// os.read_entire_file, it works on web too
	ttfData, success := io.read_entire_file(path)
	if !success {
		log.errorf("Could not find file for font ID: %v.", id)
		return {}, false
	}
	defer delete(ttfData)

	bitmap := make([]u8, BITMAP_WIDTH * BITMAP_HEIGHT)
	defer delete(bitmap)

	font := Font {
		name = strings.clone(name),
	}

	ret := tt.BakeFontBitmap(
		raw_data(ttfData),
		0,
		f32(size),
		raw_data(bitmap),
		BITMAP_WIDTH,
		BITMAP_HEIGHT,
		32,
		96,
		&font.charData[0],
	)
	if ret <= 0 {
		log.errorf("Bitmap is too small for selected font ID: %v, size: %v.", id, size)
		return {}, false
	}

	description := sg.Image_Desc {
		width        = BITMAP_WIDTH,
		height       = BITMAP_HEIGHT,
		pixel_format = .R8,
		label        = "font_texture",
	}
	description.data.subimage[0][0] = {
		ptr  = raw_data(bitmap),
		size = len(bitmap),
	}

	// store the image just for cleanup purposes
	// its just 4 bytes (u32) anyway
	font.texture = sg.make_image(description)
	if font.texture.id == sg.INVALID_ID {
		log.errorf("Failed to create an image for font ID %v.", id)
		return {}, false
	}

	font.view = sg.make_view({texture = sg.Texture_View_Desc{image = font.texture}})
	if font.view.id == sg.INVALID_ID {
		log.errorf("Failed to create a view for font ID %v.", id)
		return {}, false
	}

	setFontTexture(font.view)

	// cache the font data so that it doesnt have to regenerate each frame
	_fontCache[strings.clone(key)] = font

	return font, true
}

destroyFonts :: proc() {
	for key, font in _fontCache {
		sg.destroy_image(font.texture)
		sg.destroy_view(font.view)
		delete(font.name)
		delete(key)
	}
	delete(_fontCache)
}
